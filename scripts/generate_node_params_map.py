#!/usr/bin/env python3
"""
Script to generate the node parameters factory map.

This script creates a C++ unordered_map that maps ImGui function names
to factory functions that create unique_ptr<IParamsBase> instances
for each function's parameter struct.
"""

import os
import json
import re

BLOCKS_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '../src/core/components/blocks'))
JSON_PATH = os.path.join(os.path.dirname(__file__), 'output', 'imgui_functions.json')
MAPS_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '../src/generated/maps'))
SRC_MAPS_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '../src/core/types/maps'))
default_output = os.path.join(MAPS_DIR, 'NodeParamsMap.hpp')
default_stub_output = os.path.join(SRC_MAPS_DIR, 'NodeParamsMap.hpp')

def struct_name(func_name, func_index, functions):
    """Generate struct name from function name, handling overloads."""
    # Count how many functions with this name exist
    overload_count = sum(1 for f in functions if f['name'] == func_name)
    
    if overload_count == 1:
        return f"{func_name}Params"
    else:
        # Find the index of this function among overloads
        overload_index = sum(1 for f in functions[:func_index] if f['name'] == func_name)
        return f"{func_name}Params{overload_index + 1}"

def main(output_path=default_output, stub_output_path=default_stub_output):
    """
    Generate the node parameters factory map.

    Reads ImGui functions from JSON, checks for existing param headers,
    and generates a map of factory functions.
    """
    print("Starting node params factory map generation...")

    if not os.path.exists(JSON_PATH):
        print(f"Error: JSON file not found at {JSON_PATH}")
        return

    # Load all ImGui function names
    with open(JSON_PATH, 'r') as f:
        functions = json.load(f)

    print(f"Loaded {len(functions)} functions from {JSON_PATH}")

    params_map_entries = []
    processed_count = 0

    for func_index, func in enumerate(functions):
        name = func['name']
        class_name = struct_name(name, func_index, functions)
        # Since all params are in a single file, we don't need to check for individual headers
        params_map_entries.append(f'    {{"{name}", []() -> std::unique_ptr<IParamsBase> {{ return std::make_unique<{class_name}>(); }}}}')
        processed_count += 1

    print(f"Processed {processed_count} functions, skipped 0 due to missing headers")

    # Write C++ header with map
    out_dir = os.path.dirname(output_path)
    os.makedirs(out_dir, exist_ok=True)

    with open(output_path, 'w') as f:
        f.write('#pragma once\n')
        f.write('// This file is autogenerated by scripts/generate_node_params_map.py. Do not edit manually.\n')
        f.write('// Auto-generated NodeParamsFactory map\n')
        f.write('#include <string>\n#include <unordered_map>\n#include <memory>\n#include <functional>\n#include <utility>\n')
        f.write('#include "core/types/interfaces/IParamsBase.hpp"\n')
        f.write('#include "../params/ImGuiBlockParams.hpp"\n')
        f.write('\nnamespace core {\n')
        f.write('static const std::unordered_map<std::string, std::function<std::unique_ptr<IParamsBase>()>> NODE_PARAMS_FACTORY = {\n')
        
        # Write all the entries
        for entry in params_map_entries:
            f.write(f'{entry},\n')
        
        f.write('};\n')
        f.write('} // namespace core\n')

    print(f"Node params factory map written to {output_path} with {len(params_map_entries)} entries")

    # Create stub file in src directory
    os.makedirs(os.path.dirname(stub_output_path), exist_ok=True)
    with open(stub_output_path, 'w') as f:
        f.write('// This file is autogenerated by scripts/generate_node_params_map.py. Do not edit manually, but edit the respective scripts to reflect the needed changes!\n')
        f.write('#include "generated/maps/NodeParamsMap.hpp"\n')

    print(f"Stub file written to {stub_output_path}")

if __name__ == "__main__":
    main()
